{"hash":"51486d55cd67a9a32bc4c658860ada49e1bb2adf","fesm2022":[{"exports":["Ng2GaugeComponent","Ng2GaugeModule"],"facadeModuleId":"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/ng2-gauge.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/shared/ng2-gauge.interface.mjs","/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/shared/config.mjs","/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/shared/validators.mjs","/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/ng2-gauge.component.mjs","/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/ng2-gauge.module.mjs","/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/public_api.mjs","/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/ng2-gauge.mjs"],"name":"ng2-gauge","type":"chunk","dynamicImports":[],"fileName":"ng2-gauge.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["*","Component","ViewEncapsulation","ViewChild","Input","NgModule"],"@angular/common":["*"],"@angular/platform-browser":["BrowserModule"]},"imports":["@angular/core","@angular/common","@angular/platform-browser"],"modules":{"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/shared/ng2-gauge.interface.mjs":{"code":"var Separator;\n(function (Separator) {\n    Separator[Separator[\"NA\"] = 0] = \"NA\";\n    Separator[Separator[\"Big\"] = 1] = \"Big\";\n    Separator[Separator[\"Small\"] = 2] = \"Small\";\n})(Separator || (Separator = {}));","originalLength":1632,"removedExports":[],"renderedExports":["Separator"],"renderedLength":210},"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/shared/config.mjs":{"code":"const Config = {\n    WIDTH: 200,\n    ARC_STROKE: 5,\n    ARROW_Y: 22.5,\n    ARROW_WIDTH: 4,\n    ARROW_PIN_RAD: 8,\n    SL_NORM: 3,\n    SL_MID_SEP: 7,\n    SL_SEP: 10,\n    SL_WIDTH: 2,\n    TXT_MARGIN: 10,\n    LIGHT_Y: 55,\n    LIGHT_RADIUS: 10,\n    S_FAC_Y: 80,\n    DIGITAL_Y: 145,\n    UNIT_Y: 155,\n    MAX_PURE_SCALE_VAL: 1000,\n    INIT_LINE_FREQ: 2,\n    DEF_START: 225,\n    DEF_END: 135\n};","originalLength":3584,"removedExports":[],"renderedExports":["Config"],"renderedLength":386},"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/shared/validators.mjs":{"code":"const showError = (text) => {\n    console.error(`GaugeComponent: ${text}`);\n};\nconst validate = (props) => {\n    if (!props.max) {\n        showError('The maximal value is not set.');\n    }\n    if (!(0 <= props.start && props.start <= 359) || !(0 <= props.end && props.end <= 359)) {\n        showError('The end and start must be between 0 and 359 degrees.');\n    }\n    if (props.light && props.light > props.max) {\n        showError('The red light trigger value cannot be greater than the max value of the gauge.');\n    }\n    if (props.factor && props.factor >= props.max) {\n        showError('The factor cannot be greater than or equal to the max value.');\n    }\n    if (props.sectors) {\n        props.sectors.forEach((s) => {\n            if (s.from > props.max || s.to > props.max) {\n                showError('The sector bounds cannot be greater than the max value.');\n            }\n            if (s.from >= s.to) {\n                showError('The lower bound of the sector cannot be greater than or equal to the upper one.');\n            }\n            if (!s.color) {\n                showError(`Sector[${s.from}, ${s.to}] color is empty.`);\n            }\n        });\n    }\n};","originalLength":4572,"removedExports":[],"renderedExports":["validate"],"renderedLength":1178},"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/ng2-gauge.component.mjs":{"code":"const _c0 = [\"gauge\"];\nconst _c1 = [\"arrow\"];\nfunction Ng2GaugeComponent__svg_circle_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"circle\", 15);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"on\", ctx_r0.input >= ctx_r0.light);\n    i0.ɵɵattribute(\"cx\", ctx_r0.center)(\"cy\", ctx_r0.config.LIGHT_Y)(\"r\", ctx_r0.config.LIGHT_RADIUS);\n} }\nfunction Ng2GaugeComponent__svg_text_3_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 16);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"x\", ctx_r1.center)(\"y\", ctx_r1.config.S_FAC_Y);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate2(\" x\", ctx_r1.scaleFactor, \" \", ctx_r1.unit, \" \");\n} }\nfunction Ng2GaugeComponent__svg_text_4_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 17);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"x\", ctx_r2.center)(\"y\", ctx_r2.config.DIGITAL_Y);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.input, \" \");\n} }\nfunction Ng2GaugeComponent__svg_path_10_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"path\", 18);\n} if (rf & 2) {\n    const arc_r8 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"d\", arc_r8.path)(\"stroke\", arc_r8.color)(\"stroke-width\", ctx_r4.config.ARC_STROKE);\n} }\nfunction Ng2GaugeComponent__svg_line_11_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"line\");\n} if (rf & 2) {\n    const line_r9 = ctx.$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"stroke-width\", ctx_r5.config.SL_WIDTH)(\"stroke\", line_r9.color || (!ctx_r5.lightTheme ? \"#333\" : \"#fff\"))(\"x1\", line_r9.from.x)(\"y1\", line_r9.from.y)(\"x2\", line_r9.to.x)(\"y2\", line_r9.to.y);\n} }\nfunction Ng2GaugeComponent__svg_text_12_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 19);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const val_r10 = ctx.$implicit;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"x\", val_r10.coor.x)(\"y\", val_r10.coor.y)(\"transform\", \"rotate(\" + ctx_r6.gaugeRotationAngle + \", \" + val_r10.coor.x + \", \" + val_r10.coor.y + \")\");\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", val_r10.text, \" \");\n} }\nclass Ng2GaugeComponent {\n    constructor(_renderer) {\n        this._renderer = _renderer;\n    }\n    set input(val) {\n        this._input = val;\n        this._updateArrowPos(val);\n    }\n    get input() {\n        return this._input;\n    }\n    set max(val) {\n        if (this._max) {\n            this._max = val;\n            this._initialize();\n        }\n        this._max = val;\n    }\n    get max() {\n        return this._max;\n    }\n    get arc() {\n        return this._arc(0, this._end);\n    }\n    get gaugeRotationAngle() {\n        return this._end - this.end;\n    }\n    ngOnInit() {\n        this.config = Object.assign(Config, this.config);\n        if (!this.start) {\n            this.start = this.config.DEF_START;\n        }\n        if (!this.end) {\n            this.end = this.config.DEF_END;\n        }\n        validate(this);\n        const width = this.config.WIDTH + this.config.ARC_STROKE;\n        this.viewBox = `0 0 ${width} ${width}`;\n        this.radius = this.config.WIDTH / 2;\n        this.center = width / 2;\n        this._end = this.end;\n        if (this.start > this.end) {\n            this._end += 360 - this.start;\n        }\n        else {\n            this._end -= this.start;\n        }\n        this._initialize();\n    }\n    ngAfterViewInit() {\n        this._rotateGauge();\n    }\n    /**\n     * Initialize gauge.\n     */\n    _initialize() {\n        this.scaleLines = [];\n        this.scaleValues = [];\n        this._calculateSectors();\n        this._updateArrowPos(this._input);\n        this.scaleFactor = this.factor || this._determineScaleFactor();\n        this._createScale();\n    }\n    /**\n     * Calculate arc.\n     */\n    _arc(start, end) {\n        const largeArc = end - start <= 180 ? 0 : 1;\n        const startCoor = this._getAngleCoor(start);\n        const endCoor = this._getAngleCoor(end);\n        return `M ${endCoor.x} ${endCoor.y} A ${this.radius} ${this.radius} 0 ${largeArc} 0 ${startCoor.x} ${startCoor.y}`;\n    }\n    /**\n     * Get angle coordinates (Cartesian coordinates).\n     */\n    _getAngleCoor(degrees) {\n        const rads = ((degrees - 90) * Math.PI) / 180;\n        return {\n            x: this.radius * Math.cos(rads) + this.center,\n            y: this.radius * Math.sin(rads) + this.center,\n        };\n    }\n    /**\n     * Calculate/translate the user-defined sectors to arcs.\n     */\n    _calculateSectors() {\n        if (!this.sectors) {\n            return;\n        }\n        this._mappedSectors = JSON.parse(JSON.stringify(this.sectors));\n        this._mappedSectors.forEach((s) => {\n            const ratio = this._end / this.max;\n            s.from *= ratio;\n            s.to *= ratio;\n        });\n        this.sectorArcs = this._mappedSectors.map((s) => {\n            return {\n                path: this._arc(s.from, s.to),\n                color: s.color,\n            };\n        });\n    }\n    /**\n     * Update the position of the arrow based on the input.\n     */\n    _updateArrowPos(input) {\n        const pos = (this._end / this.max) * input;\n        this._renderer.setStyle(this.arrow.nativeElement, 'transform', `rotate(${pos}deg)`);\n    }\n    /**\n     * Rotate the gauge based on the start property. The CSS rotation, saves additional calculations with SVG.\n     */\n    _rotateGauge() {\n        const angle = 360 - this.start;\n        this._renderer.setStyle(this.gauge.nativeElement, 'transform', `rotate(-${angle}deg)`);\n    }\n    /**\n     * Determine the scale factor (10^n number; i.e. if max = 9000 then scale_factor = 1000)\n     */\n    _determineScaleFactor(factor = 10) {\n        // Keep smaller factor until 3X\n        if (this.max / factor > 30) {\n            return this._determineScaleFactor(factor * 10);\n        }\n        return factor;\n    }\n    /**\n     * Determine the line frequency which represents after what angle we should put a line.\n     */\n    _determineLineFrequency() {\n        const separators = this.max / this.scaleFactor;\n        const separateAtAngle = this._end / separators;\n        let lineFrequency;\n        // If separateAtAngle is not an integer, use its value as the line frequency.\n        if (separateAtAngle % 1 !== 0) {\n            lineFrequency = separateAtAngle;\n        }\n        else {\n            lineFrequency = this.config.INIT_LINE_FREQ * 2;\n            for (lineFrequency; lineFrequency <= separateAtAngle; lineFrequency++) {\n                if (separateAtAngle % lineFrequency === 0) {\n                    break;\n                }\n            }\n        }\n        return lineFrequency;\n    }\n    /**\n     * Checks whether the line (based on index) is big or small separator.\n     */\n    _isSeparatorReached(idx, lineFrequency) {\n        const separators = this.max / this.scaleFactor;\n        const totalSeparators = this._end / lineFrequency;\n        const separateAtIdx = totalSeparators / separators;\n        if (idx % separateAtIdx === 0) {\n            return Separator.Big;\n        }\n        else if (idx % (separateAtIdx / 2) === 0) {\n            return Separator.Small;\n        }\n        return Separator.NA;\n    }\n    /**\n     * Creates the scale.\n     */\n    _createScale() {\n        const accumWith = this._determineLineFrequency() / 2;\n        const isAboveSuitableFactor = this.max / this.scaleFactor > 10;\n        let placedVals = 0;\n        for (let alpha = 0, i = 0; alpha >= -1 * this._end; alpha -= accumWith, i++) {\n            let lineHeight = this.config.SL_NORM;\n            const sepReached = this._isSeparatorReached(i, accumWith);\n            // Set the line height based on its type\n            switch (sepReached) {\n                case Separator.Big:\n                    placedVals++;\n                    lineHeight = this.config.SL_SEP;\n                    break;\n                case Separator.Small:\n                    lineHeight = this.config.SL_MID_SEP;\n                    break;\n            }\n            // Draw the line\n            const higherEnd = this.center - this.config.ARC_STROKE - 2;\n            const lowerEnd = higherEnd - lineHeight;\n            const alphaRad = (Math.PI / 180) * (alpha + 180);\n            const sin = Math.sin(alphaRad);\n            const cos = Math.cos(alphaRad);\n            const color = this._getScaleLineColor(alpha);\n            this._addScaleLine(sin, cos, higherEnd, lowerEnd, color);\n            // Put a scale value\n            if (sepReached === Separator.Big) {\n                const isValuePosEven = placedVals % 2 === 0;\n                const isLast = alpha <= -1 * this._end;\n                if (!(isAboveSuitableFactor && isValuePosEven && !isLast)) {\n                    this._addScaleValue(sin, cos, lowerEnd, alpha);\n                }\n            }\n        }\n    }\n    /**\n     * Get the scale line color from the user-provided sectors definitions.\n     */\n    _getScaleLineColor(alpha) {\n        alpha *= -1;\n        let color = '';\n        if (this._mappedSectors) {\n            this._mappedSectors.forEach((s) => {\n                if (s.from <= alpha && alpha <= s.to) {\n                    color = s.color;\n                }\n            });\n        }\n        return color;\n    }\n    /**\n     * Add a scale line to the list that will be later rendered.\n     */\n    _addScaleLine(sin, cos, higherEnd, lowerEnd, color) {\n        this.scaleLines.push({\n            from: {\n                x: sin * higherEnd + this.center,\n                y: cos * higherEnd + this.center,\n            },\n            to: {\n                x: sin * lowerEnd + this.center,\n                y: cos * lowerEnd + this.center,\n            },\n            color,\n        });\n    }\n    /**\n     * Add a scale value.\n     */\n    _addScaleValue(sin, cos, lowerEnd, alpha) {\n        let val = Math.round(alpha * (this.max / this._end)) * -1;\n        let posMargin = this.config.TXT_MARGIN * 2;\n        // Use the multiplier instead of the real value, if above MAX_PURE_SCALE_VAL (i.e. 1000)\n        if (this.max > this.config.MAX_PURE_SCALE_VAL) {\n            val /= this.scaleFactor;\n            val = Math.round(val * 100) / 100;\n            posMargin /= 2;\n        }\n        this.scaleValues.push({\n            text: val.toString(),\n            coor: {\n                x: sin * (lowerEnd - posMargin) + this.center,\n                y: cos * (lowerEnd - posMargin) + this.center,\n            },\n        });\n    }\n    static { this.ɵfac = function Ng2GaugeComponent_Factory(t) { return new (t || Ng2GaugeComponent)(i0.ɵɵdirectiveInject(i0.Renderer2)); }; }\n    static { this.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: Ng2GaugeComponent, selectors: [[\"nga-ng2-gauge\"]], viewQuery: function Ng2GaugeComponent_Query(rf, ctx) { if (rf & 1) {\n            i0.ɵɵviewQuery(_c0, 5);\n            i0.ɵɵviewQuery(_c1, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gauge = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.arrow = _t.first);\n        } }, inputs: { size: \"size\", start: \"start\", end: \"end\", sectors: \"sectors\", unit: \"unit\", showDigital: \"showDigital\", light: \"light\", lightTheme: \"lightTheme\", factor: \"factor\", config: \"config\", input: \"input\", max: \"max\" }, decls: 16, vars: 26, consts: [[1, \"ng-gauge\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", 1, \"info\"], [\"class\", \"red-light\", 3, \"on\", 4, \"ngIf\"], [\"class\", \"factor\", 4, \"ngIf\"], [\"class\", \"digital\", 4, \"ngIf\"], [1, \"unit\"], [\"xmlns\", \"http://www.w3.org/2000/svg\"], [\"gauge\", \"\"], [\"fill\", \"none\", 1, \"main-arc\"], [\"fill\", \"none\", 4, \"ngFor\", \"ngForOf\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"text-val\", \"dominant-baseline\", \"central\", 4, \"ngFor\", \"ngForOf\"], [1, \"arrow\"], [\"arrow\", \"\"], [1, \"arrow-pin\"], [1, \"red-light\"], [1, \"factor\"], [1, \"digital\"], [\"fill\", \"none\"], [\"dominant-baseline\", \"central\", 1, \"text-val\"]], template: function Ng2GaugeComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"section\", 0);\n            i0.ɵɵnamespaceSVG();\n            i0.ɵɵelementStart(1, \"svg\", 1);\n            i0.ɵɵtemplate(2, Ng2GaugeComponent__svg_circle_2_Template, 1, 5, \"circle\", 2)(3, Ng2GaugeComponent__svg_text_3_Template, 2, 4, \"text\", 3)(4, Ng2GaugeComponent__svg_text_4_Template, 2, 3, \"text\", 4);\n            i0.ɵɵelementStart(5, \"text\", 5);\n            i0.ɵɵtext(6);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(7, \"svg\", 6, 7);\n            i0.ɵɵelement(9, \"path\", 8);\n            i0.ɵɵtemplate(10, Ng2GaugeComponent__svg_path_10_Template, 1, 3, \"path\", 9)(11, Ng2GaugeComponent__svg_line_11_Template, 1, 6, \"line\", 10)(12, Ng2GaugeComponent__svg_text_12_Template, 2, 4, \"text\", 11);\n            i0.ɵɵelement(13, \"rect\", 12, 13)(15, \"circle\", 14);\n            i0.ɵɵelementEnd()();\n        } if (rf & 2) {\n            i0.ɵɵstyleProp(\"width\", ctx.size + \"px\");\n            i0.ɵɵclassProp(\"light\", ctx.lightTheme);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"viewBox\", ctx.viewBox);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.light);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.max > ctx.config.MAX_PURE_SCALE_VAL);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.showDigital);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"x\", ctx.center)(\"y\", ctx.config.UNIT_Y);\n            i0.ɵɵadvance();\n            i0.ɵɵtextInterpolate(ctx.unit);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"viewBox\", ctx.viewBox);\n            i0.ɵɵadvance(2);\n            i0.ɵɵattribute(\"d\", ctx.arc)(\"stroke-width\", ctx.config.ARC_STROKE);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngForOf\", ctx.sectorArcs);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngForOf\", ctx.scaleLines);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngForOf\", ctx.scaleValues);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"x\", ctx.center - ctx.config.ARROW_WIDTH / 2)(\"y\", ctx.config.ARROW_Y)(\"height\", ctx.center - ctx.config.ARROW_Y)(\"width\", ctx.config.ARROW_WIDTH)(\"rx\", ctx.config.ARROW_WIDTH / 2)(\"ry\", ctx.config.ARROW_WIDTH / 2);\n            i0.ɵɵadvance(2);\n            i0.ɵɵattribute(\"cx\", ctx.center)(\"cy\", ctx.center)(\"r\", ctx.config.ARROW_PIN_RAD);\n        } }, dependencies: [i1.NgForOf, i1.NgIf], styles: [\"@font-face{font-family:Orbitron;font-style:normal;font-weight:700;src:local(\\\"Orbitron Bold\\\"),local(\\\"Orbitron-Bold\\\"),url(https://fonts.gstatic.com/s/orbitron/v8/Y82YH_MJJWnsH2yUA5AuYY4P5ICox8Kq3LLUNMylGO4.woff2) format(\\\"woff2\\\");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2212,U+2215}.ng-gauge{position:relative;width:400px}.ng-gauge svg.info{position:absolute;top:0;left:0}.ng-gauge rect.arrow{transform-origin:50% 50%;fill:orange}.ng-gauge text{font-family:Orbitron,sans-serif;font-weight:700;text-anchor:middle;fill:#333}.ng-gauge.light text{fill:#fff}.ng-gauge text.text-val{font-size:12px}.ng-gauge circle.arrow-pin{fill:#333}.ng-gauge path.main-arc{stroke:#333}.ng-gauge.light path.main-arc{stroke:#fff}.ng-gauge text.factor{font-size:7px}.ng-gauge text.digital{font-size:16px}.ng-gauge text.unit{font-size:10px}.ng-gauge circle.red-light{fill:#ff4f4f;opacity:.1}.ng-gauge circle.red-light.on{opacity:1}\\n\"], encapsulation: 2 }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Ng2GaugeComponent, [{\n        type: Component,\n        args: [{ selector: 'nga-ng2-gauge', encapsulation: ViewEncapsulation.None, template: \"<section class=\\\"ng-gauge\\\" [class.light]=\\\"lightTheme\\\" [style.width]=\\\"size + 'px'\\\">\\n  <svg class=\\\"info\\\" [attr.viewBox]=\\\"viewBox\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <circle *ngIf=\\\"light\\\"  class=\\\"red-light\\\"\\n      [class.on]=\\\"input >= light\\\"\\n      [attr.cx]=\\\"center\\\"\\n      [attr.cy]=\\\"config.LIGHT_Y\\\"\\n      [attr.r]=\\\"config.LIGHT_RADIUS\\\">\\n    </circle>\\n    <text *ngIf=\\\"max > config.MAX_PURE_SCALE_VAL\\\"\\n      class=\\\"factor\\\"\\n      [attr.x]=\\\"center\\\"\\n      [attr.y]=\\\"config.S_FAC_Y\\\">\\n      x{{scaleFactor}} {{unit}}\\n    </text>\\n    <text *ngIf=\\\"showDigital\\\"\\n      class=\\\"digital\\\"\\n      [attr.x]=\\\"center\\\"\\n      [attr.y]=\\\"config.DIGITAL_Y\\\">\\n      {{input}}\\n    </text>\\n    <text class=\\\"unit\\\" [attr.x]=\\\"center\\\" [attr.y]=\\\"config.UNIT_Y\\\">{{unit}}</text>\\n  </svg>\\n  <svg #gauge [attr.viewBox]=\\\"viewBox\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path class=\\\"main-arc\\\" [attr.d]=\\\"arc\\\" [attr.stroke-width]=\\\"config.ARC_STROKE\\\" fill=\\\"none\\\" />\\n    <path *ngFor=\\\"let arc of sectorArcs\\\"\\n      [attr.d]=\\\"arc.path\\\"\\n      [attr.stroke]=\\\"arc.color\\\"\\n      [attr.stroke-width]=\\\"config.ARC_STROKE\\\"\\n      fill=\\\"none\\\" />\\n    <line *ngFor=\\\"let line of scaleLines\\\"\\n      [attr.stroke-width]=\\\"config.SL_WIDTH\\\"\\n      [attr.stroke]=\\\"line.color || (!lightTheme ? '#333' : '#fff')\\\"\\n      [attr.x1]=\\\"line.from.x\\\"\\n      [attr.y1]=\\\"line.from.y\\\"\\n      [attr.x2]=\\\"line.to.x\\\"\\n      [attr.y2]=\\\"line.to.y\\\" />\\n    <text *ngFor=\\\"let val of scaleValues\\\"\\n      class=\\\"text-val\\\"\\n      dominant-baseline=\\\"central\\\"\\n      [attr.x]=\\\"val.coor.x\\\"\\n      [attr.y]=\\\"val.coor.y\\\"\\n      [attr.transform]=\\\"'rotate(' + gaugeRotationAngle + ', ' + val.coor.x + ', ' + val.coor.y + ')'\\\">\\n      {{val.text}}\\n    </text>\\n    <rect #arrow\\n      class=\\\"arrow\\\"\\n      [attr.x]=\\\"center - config.ARROW_WIDTH / 2\\\"\\n      [attr.y]=\\\"config.ARROW_Y\\\"\\n      [attr.height]=\\\"center - config.ARROW_Y\\\"\\n      [attr.width]=\\\"config.ARROW_WIDTH\\\"\\n      [attr.rx]=\\\"config.ARROW_WIDTH / 2\\\"\\n      [attr.ry]=\\\"config.ARROW_WIDTH / 2\\\">\\n    </rect>\\n    <circle class=\\\"arrow-pin\\\" [attr.cx]=\\\"center\\\" [attr.cy]=\\\"center\\\" [attr.r]=\\\"config.ARROW_PIN_RAD\\\" />\\n  </svg>\\n</section>\\n\", styles: [\"@font-face{font-family:Orbitron;font-style:normal;font-weight:700;src:local(\\\"Orbitron Bold\\\"),local(\\\"Orbitron-Bold\\\"),url(https://fonts.gstatic.com/s/orbitron/v8/Y82YH_MJJWnsH2yUA5AuYY4P5ICox8Kq3LLUNMylGO4.woff2) format(\\\"woff2\\\");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2212,U+2215}.ng-gauge{position:relative;width:400px}.ng-gauge svg.info{position:absolute;top:0;left:0}.ng-gauge rect.arrow{transform-origin:50% 50%;fill:orange}.ng-gauge text{font-family:Orbitron,sans-serif;font-weight:700;text-anchor:middle;fill:#333}.ng-gauge.light text{fill:#fff}.ng-gauge text.text-val{font-size:12px}.ng-gauge circle.arrow-pin{fill:#333}.ng-gauge path.main-arc{stroke:#333}.ng-gauge.light path.main-arc{stroke:#fff}.ng-gauge text.factor{font-size:7px}.ng-gauge text.digital{font-size:16px}.ng-gauge text.unit{font-size:10px}.ng-gauge circle.red-light{fill:#ff4f4f;opacity:.1}.ng-gauge circle.red-light.on{opacity:1}\\n\"] }]\n    }], () => [{ type: i0.Renderer2 }], { gauge: [{\n            type: ViewChild,\n            args: ['gauge']\n        }], arrow: [{\n            type: ViewChild,\n            args: ['arrow']\n        }], size: [{\n            type: Input\n        }], start: [{\n            type: Input\n        }], end: [{\n            type: Input\n        }], sectors: [{\n            type: Input\n        }], unit: [{\n            type: Input\n        }], showDigital: [{\n            type: Input\n        }], light: [{\n            type: Input\n        }], lightTheme: [{\n            type: Input\n        }], factor: [{\n            type: Input\n        }], config: [{\n            type: Input\n        }], input: [{\n            type: Input\n        }], max: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(Ng2GaugeComponent, { className: \"Ng2GaugeComponent\" }); })();","originalLength":48551,"removedExports":[],"renderedExports":["Ng2GaugeComponent"],"renderedLength":19995},"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/lib/ng2-gauge.module.mjs":{"code":"class Ng2GaugeModule {\n    static { this.ɵfac = function Ng2GaugeModule_Factory(t) { return new (t || Ng2GaugeModule)(); }; }\n    static { this.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: Ng2GaugeModule }); }\n    static { this.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [BrowserModule] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Ng2GaugeModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [Ng2GaugeComponent],\n                imports: [\n                    BrowserModule\n                ],\n                exports: [Ng2GaugeComponent]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(Ng2GaugeModule, { declarations: [Ng2GaugeComponent], imports: [BrowserModule], exports: [Ng2GaugeComponent] }); })();","originalLength":2283,"removedExports":[],"renderedExports":["Ng2GaugeModule"],"renderedLength":872},"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/public_api.mjs":{"code":"/*\n * Public API Surface of ng2-gauge\n */","originalLength":639,"removedExports":[],"renderedExports":[],"renderedLength":41},"/Users/georgi/Developer/ng2-gauge/dist/ng2-gauge/esm2022/ng2-gauge.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":492,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { Component, ViewEncapsulation, ViewChild, Input, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { BrowserModule } from '@angular/platform-browser';\n\nvar Separator;\n(function (Separator) {\n    Separator[Separator[\"NA\"] = 0] = \"NA\";\n    Separator[Separator[\"Big\"] = 1] = \"Big\";\n    Separator[Separator[\"Small\"] = 2] = \"Small\";\n})(Separator || (Separator = {}));\n\nconst Config = {\n    WIDTH: 200,\n    ARC_STROKE: 5,\n    ARROW_Y: 22.5,\n    ARROW_WIDTH: 4,\n    ARROW_PIN_RAD: 8,\n    SL_NORM: 3,\n    SL_MID_SEP: 7,\n    SL_SEP: 10,\n    SL_WIDTH: 2,\n    TXT_MARGIN: 10,\n    LIGHT_Y: 55,\n    LIGHT_RADIUS: 10,\n    S_FAC_Y: 80,\n    DIGITAL_Y: 145,\n    UNIT_Y: 155,\n    MAX_PURE_SCALE_VAL: 1000,\n    INIT_LINE_FREQ: 2,\n    DEF_START: 225,\n    DEF_END: 135\n};\n\nconst showError = (text) => {\n    console.error(`GaugeComponent: ${text}`);\n};\nconst validate = (props) => {\n    if (!props.max) {\n        showError('The maximal value is not set.');\n    }\n    if (!(0 <= props.start && props.start <= 359) || !(0 <= props.end && props.end <= 359)) {\n        showError('The end and start must be between 0 and 359 degrees.');\n    }\n    if (props.light && props.light > props.max) {\n        showError('The red light trigger value cannot be greater than the max value of the gauge.');\n    }\n    if (props.factor && props.factor >= props.max) {\n        showError('The factor cannot be greater than or equal to the max value.');\n    }\n    if (props.sectors) {\n        props.sectors.forEach((s) => {\n            if (s.from > props.max || s.to > props.max) {\n                showError('The sector bounds cannot be greater than the max value.');\n            }\n            if (s.from >= s.to) {\n                showError('The lower bound of the sector cannot be greater than or equal to the upper one.');\n            }\n            if (!s.color) {\n                showError(`Sector[${s.from}, ${s.to}] color is empty.`);\n            }\n        });\n    }\n};\n\nconst _c0 = [\"gauge\"];\nconst _c1 = [\"arrow\"];\nfunction Ng2GaugeComponent__svg_circle_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"circle\", 15);\n} if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"on\", ctx_r0.input >= ctx_r0.light);\n    i0.ɵɵattribute(\"cx\", ctx_r0.center)(\"cy\", ctx_r0.config.LIGHT_Y)(\"r\", ctx_r0.config.LIGHT_RADIUS);\n} }\nfunction Ng2GaugeComponent__svg_text_3_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 16);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"x\", ctx_r1.center)(\"y\", ctx_r1.config.S_FAC_Y);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate2(\" x\", ctx_r1.scaleFactor, \" \", ctx_r1.unit, \" \");\n} }\nfunction Ng2GaugeComponent__svg_text_4_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 17);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"x\", ctx_r2.center)(\"y\", ctx_r2.config.DIGITAL_Y);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r2.input, \" \");\n} }\nfunction Ng2GaugeComponent__svg_path_10_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"path\", 18);\n} if (rf & 2) {\n    const arc_r8 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"d\", arc_r8.path)(\"stroke\", arc_r8.color)(\"stroke-width\", ctx_r4.config.ARC_STROKE);\n} }\nfunction Ng2GaugeComponent__svg_line_11_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"line\");\n} if (rf & 2) {\n    const line_r9 = ctx.$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"stroke-width\", ctx_r5.config.SL_WIDTH)(\"stroke\", line_r9.color || (!ctx_r5.lightTheme ? \"#333\" : \"#fff\"))(\"x1\", line_r9.from.x)(\"y1\", line_r9.from.y)(\"x2\", line_r9.to.x)(\"y2\", line_r9.to.y);\n} }\nfunction Ng2GaugeComponent__svg_text_12_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 19);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n} if (rf & 2) {\n    const val_r10 = ctx.$implicit;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"x\", val_r10.coor.x)(\"y\", val_r10.coor.y)(\"transform\", \"rotate(\" + ctx_r6.gaugeRotationAngle + \", \" + val_r10.coor.x + \", \" + val_r10.coor.y + \")\");\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", val_r10.text, \" \");\n} }\nclass Ng2GaugeComponent {\n    constructor(_renderer) {\n        this._renderer = _renderer;\n    }\n    set input(val) {\n        this._input = val;\n        this._updateArrowPos(val);\n    }\n    get input() {\n        return this._input;\n    }\n    set max(val) {\n        if (this._max) {\n            this._max = val;\n            this._initialize();\n        }\n        this._max = val;\n    }\n    get max() {\n        return this._max;\n    }\n    get arc() {\n        return this._arc(0, this._end);\n    }\n    get gaugeRotationAngle() {\n        return this._end - this.end;\n    }\n    ngOnInit() {\n        this.config = Object.assign(Config, this.config);\n        if (!this.start) {\n            this.start = this.config.DEF_START;\n        }\n        if (!this.end) {\n            this.end = this.config.DEF_END;\n        }\n        validate(this);\n        const width = this.config.WIDTH + this.config.ARC_STROKE;\n        this.viewBox = `0 0 ${width} ${width}`;\n        this.radius = this.config.WIDTH / 2;\n        this.center = width / 2;\n        this._end = this.end;\n        if (this.start > this.end) {\n            this._end += 360 - this.start;\n        }\n        else {\n            this._end -= this.start;\n        }\n        this._initialize();\n    }\n    ngAfterViewInit() {\n        this._rotateGauge();\n    }\n    /**\n     * Initialize gauge.\n     */\n    _initialize() {\n        this.scaleLines = [];\n        this.scaleValues = [];\n        this._calculateSectors();\n        this._updateArrowPos(this._input);\n        this.scaleFactor = this.factor || this._determineScaleFactor();\n        this._createScale();\n    }\n    /**\n     * Calculate arc.\n     */\n    _arc(start, end) {\n        const largeArc = end - start <= 180 ? 0 : 1;\n        const startCoor = this._getAngleCoor(start);\n        const endCoor = this._getAngleCoor(end);\n        return `M ${endCoor.x} ${endCoor.y} A ${this.radius} ${this.radius} 0 ${largeArc} 0 ${startCoor.x} ${startCoor.y}`;\n    }\n    /**\n     * Get angle coordinates (Cartesian coordinates).\n     */\n    _getAngleCoor(degrees) {\n        const rads = ((degrees - 90) * Math.PI) / 180;\n        return {\n            x: this.radius * Math.cos(rads) + this.center,\n            y: this.radius * Math.sin(rads) + this.center,\n        };\n    }\n    /**\n     * Calculate/translate the user-defined sectors to arcs.\n     */\n    _calculateSectors() {\n        if (!this.sectors) {\n            return;\n        }\n        this._mappedSectors = JSON.parse(JSON.stringify(this.sectors));\n        this._mappedSectors.forEach((s) => {\n            const ratio = this._end / this.max;\n            s.from *= ratio;\n            s.to *= ratio;\n        });\n        this.sectorArcs = this._mappedSectors.map((s) => {\n            return {\n                path: this._arc(s.from, s.to),\n                color: s.color,\n            };\n        });\n    }\n    /**\n     * Update the position of the arrow based on the input.\n     */\n    _updateArrowPos(input) {\n        const pos = (this._end / this.max) * input;\n        this._renderer.setStyle(this.arrow.nativeElement, 'transform', `rotate(${pos}deg)`);\n    }\n    /**\n     * Rotate the gauge based on the start property. The CSS rotation, saves additional calculations with SVG.\n     */\n    _rotateGauge() {\n        const angle = 360 - this.start;\n        this._renderer.setStyle(this.gauge.nativeElement, 'transform', `rotate(-${angle}deg)`);\n    }\n    /**\n     * Determine the scale factor (10^n number; i.e. if max = 9000 then scale_factor = 1000)\n     */\n    _determineScaleFactor(factor = 10) {\n        // Keep smaller factor until 3X\n        if (this.max / factor > 30) {\n            return this._determineScaleFactor(factor * 10);\n        }\n        return factor;\n    }\n    /**\n     * Determine the line frequency which represents after what angle we should put a line.\n     */\n    _determineLineFrequency() {\n        const separators = this.max / this.scaleFactor;\n        const separateAtAngle = this._end / separators;\n        let lineFrequency;\n        // If separateAtAngle is not an integer, use its value as the line frequency.\n        if (separateAtAngle % 1 !== 0) {\n            lineFrequency = separateAtAngle;\n        }\n        else {\n            lineFrequency = this.config.INIT_LINE_FREQ * 2;\n            for (lineFrequency; lineFrequency <= separateAtAngle; lineFrequency++) {\n                if (separateAtAngle % lineFrequency === 0) {\n                    break;\n                }\n            }\n        }\n        return lineFrequency;\n    }\n    /**\n     * Checks whether the line (based on index) is big or small separator.\n     */\n    _isSeparatorReached(idx, lineFrequency) {\n        const separators = this.max / this.scaleFactor;\n        const totalSeparators = this._end / lineFrequency;\n        const separateAtIdx = totalSeparators / separators;\n        if (idx % separateAtIdx === 0) {\n            return Separator.Big;\n        }\n        else if (idx % (separateAtIdx / 2) === 0) {\n            return Separator.Small;\n        }\n        return Separator.NA;\n    }\n    /**\n     * Creates the scale.\n     */\n    _createScale() {\n        const accumWith = this._determineLineFrequency() / 2;\n        const isAboveSuitableFactor = this.max / this.scaleFactor > 10;\n        let placedVals = 0;\n        for (let alpha = 0, i = 0; alpha >= -1 * this._end; alpha -= accumWith, i++) {\n            let lineHeight = this.config.SL_NORM;\n            const sepReached = this._isSeparatorReached(i, accumWith);\n            // Set the line height based on its type\n            switch (sepReached) {\n                case Separator.Big:\n                    placedVals++;\n                    lineHeight = this.config.SL_SEP;\n                    break;\n                case Separator.Small:\n                    lineHeight = this.config.SL_MID_SEP;\n                    break;\n            }\n            // Draw the line\n            const higherEnd = this.center - this.config.ARC_STROKE - 2;\n            const lowerEnd = higherEnd - lineHeight;\n            const alphaRad = (Math.PI / 180) * (alpha + 180);\n            const sin = Math.sin(alphaRad);\n            const cos = Math.cos(alphaRad);\n            const color = this._getScaleLineColor(alpha);\n            this._addScaleLine(sin, cos, higherEnd, lowerEnd, color);\n            // Put a scale value\n            if (sepReached === Separator.Big) {\n                const isValuePosEven = placedVals % 2 === 0;\n                const isLast = alpha <= -1 * this._end;\n                if (!(isAboveSuitableFactor && isValuePosEven && !isLast)) {\n                    this._addScaleValue(sin, cos, lowerEnd, alpha);\n                }\n            }\n        }\n    }\n    /**\n     * Get the scale line color from the user-provided sectors definitions.\n     */\n    _getScaleLineColor(alpha) {\n        alpha *= -1;\n        let color = '';\n        if (this._mappedSectors) {\n            this._mappedSectors.forEach((s) => {\n                if (s.from <= alpha && alpha <= s.to) {\n                    color = s.color;\n                }\n            });\n        }\n        return color;\n    }\n    /**\n     * Add a scale line to the list that will be later rendered.\n     */\n    _addScaleLine(sin, cos, higherEnd, lowerEnd, color) {\n        this.scaleLines.push({\n            from: {\n                x: sin * higherEnd + this.center,\n                y: cos * higherEnd + this.center,\n            },\n            to: {\n                x: sin * lowerEnd + this.center,\n                y: cos * lowerEnd + this.center,\n            },\n            color,\n        });\n    }\n    /**\n     * Add a scale value.\n     */\n    _addScaleValue(sin, cos, lowerEnd, alpha) {\n        let val = Math.round(alpha * (this.max / this._end)) * -1;\n        let posMargin = this.config.TXT_MARGIN * 2;\n        // Use the multiplier instead of the real value, if above MAX_PURE_SCALE_VAL (i.e. 1000)\n        if (this.max > this.config.MAX_PURE_SCALE_VAL) {\n            val /= this.scaleFactor;\n            val = Math.round(val * 100) / 100;\n            posMargin /= 2;\n        }\n        this.scaleValues.push({\n            text: val.toString(),\n            coor: {\n                x: sin * (lowerEnd - posMargin) + this.center,\n                y: cos * (lowerEnd - posMargin) + this.center,\n            },\n        });\n    }\n    static { this.ɵfac = function Ng2GaugeComponent_Factory(t) { return new (t || Ng2GaugeComponent)(i0.ɵɵdirectiveInject(i0.Renderer2)); }; }\n    static { this.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: Ng2GaugeComponent, selectors: [[\"nga-ng2-gauge\"]], viewQuery: function Ng2GaugeComponent_Query(rf, ctx) { if (rf & 1) {\n            i0.ɵɵviewQuery(_c0, 5);\n            i0.ɵɵviewQuery(_c1, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gauge = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.arrow = _t.first);\n        } }, inputs: { size: \"size\", start: \"start\", end: \"end\", sectors: \"sectors\", unit: \"unit\", showDigital: \"showDigital\", light: \"light\", lightTheme: \"lightTheme\", factor: \"factor\", config: \"config\", input: \"input\", max: \"max\" }, decls: 16, vars: 26, consts: [[1, \"ng-gauge\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", 1, \"info\"], [\"class\", \"red-light\", 3, \"on\", 4, \"ngIf\"], [\"class\", \"factor\", 4, \"ngIf\"], [\"class\", \"digital\", 4, \"ngIf\"], [1, \"unit\"], [\"xmlns\", \"http://www.w3.org/2000/svg\"], [\"gauge\", \"\"], [\"fill\", \"none\", 1, \"main-arc\"], [\"fill\", \"none\", 4, \"ngFor\", \"ngForOf\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"text-val\", \"dominant-baseline\", \"central\", 4, \"ngFor\", \"ngForOf\"], [1, \"arrow\"], [\"arrow\", \"\"], [1, \"arrow-pin\"], [1, \"red-light\"], [1, \"factor\"], [1, \"digital\"], [\"fill\", \"none\"], [\"dominant-baseline\", \"central\", 1, \"text-val\"]], template: function Ng2GaugeComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"section\", 0);\n            i0.ɵɵnamespaceSVG();\n            i0.ɵɵelementStart(1, \"svg\", 1);\n            i0.ɵɵtemplate(2, Ng2GaugeComponent__svg_circle_2_Template, 1, 5, \"circle\", 2)(3, Ng2GaugeComponent__svg_text_3_Template, 2, 4, \"text\", 3)(4, Ng2GaugeComponent__svg_text_4_Template, 2, 3, \"text\", 4);\n            i0.ɵɵelementStart(5, \"text\", 5);\n            i0.ɵɵtext(6);\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(7, \"svg\", 6, 7);\n            i0.ɵɵelement(9, \"path\", 8);\n            i0.ɵɵtemplate(10, Ng2GaugeComponent__svg_path_10_Template, 1, 3, \"path\", 9)(11, Ng2GaugeComponent__svg_line_11_Template, 1, 6, \"line\", 10)(12, Ng2GaugeComponent__svg_text_12_Template, 2, 4, \"text\", 11);\n            i0.ɵɵelement(13, \"rect\", 12, 13)(15, \"circle\", 14);\n            i0.ɵɵelementEnd()();\n        } if (rf & 2) {\n            i0.ɵɵstyleProp(\"width\", ctx.size + \"px\");\n            i0.ɵɵclassProp(\"light\", ctx.lightTheme);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"viewBox\", ctx.viewBox);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.light);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.max > ctx.config.MAX_PURE_SCALE_VAL);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.showDigital);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"x\", ctx.center)(\"y\", ctx.config.UNIT_Y);\n            i0.ɵɵadvance();\n            i0.ɵɵtextInterpolate(ctx.unit);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"viewBox\", ctx.viewBox);\n            i0.ɵɵadvance(2);\n            i0.ɵɵattribute(\"d\", ctx.arc)(\"stroke-width\", ctx.config.ARC_STROKE);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngForOf\", ctx.sectorArcs);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngForOf\", ctx.scaleLines);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngForOf\", ctx.scaleValues);\n            i0.ɵɵadvance();\n            i0.ɵɵattribute(\"x\", ctx.center - ctx.config.ARROW_WIDTH / 2)(\"y\", ctx.config.ARROW_Y)(\"height\", ctx.center - ctx.config.ARROW_Y)(\"width\", ctx.config.ARROW_WIDTH)(\"rx\", ctx.config.ARROW_WIDTH / 2)(\"ry\", ctx.config.ARROW_WIDTH / 2);\n            i0.ɵɵadvance(2);\n            i0.ɵɵattribute(\"cx\", ctx.center)(\"cy\", ctx.center)(\"r\", ctx.config.ARROW_PIN_RAD);\n        } }, dependencies: [i1.NgForOf, i1.NgIf], styles: [\"@font-face{font-family:Orbitron;font-style:normal;font-weight:700;src:local(\\\"Orbitron Bold\\\"),local(\\\"Orbitron-Bold\\\"),url(https://fonts.gstatic.com/s/orbitron/v8/Y82YH_MJJWnsH2yUA5AuYY4P5ICox8Kq3LLUNMylGO4.woff2) format(\\\"woff2\\\");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2212,U+2215}.ng-gauge{position:relative;width:400px}.ng-gauge svg.info{position:absolute;top:0;left:0}.ng-gauge rect.arrow{transform-origin:50% 50%;fill:orange}.ng-gauge text{font-family:Orbitron,sans-serif;font-weight:700;text-anchor:middle;fill:#333}.ng-gauge.light text{fill:#fff}.ng-gauge text.text-val{font-size:12px}.ng-gauge circle.arrow-pin{fill:#333}.ng-gauge path.main-arc{stroke:#333}.ng-gauge.light path.main-arc{stroke:#fff}.ng-gauge text.factor{font-size:7px}.ng-gauge text.digital{font-size:16px}.ng-gauge text.unit{font-size:10px}.ng-gauge circle.red-light{fill:#ff4f4f;opacity:.1}.ng-gauge circle.red-light.on{opacity:1}\\n\"], encapsulation: 2 }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Ng2GaugeComponent, [{\n        type: Component,\n        args: [{ selector: 'nga-ng2-gauge', encapsulation: ViewEncapsulation.None, template: \"<section class=\\\"ng-gauge\\\" [class.light]=\\\"lightTheme\\\" [style.width]=\\\"size + 'px'\\\">\\n  <svg class=\\\"info\\\" [attr.viewBox]=\\\"viewBox\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <circle *ngIf=\\\"light\\\"  class=\\\"red-light\\\"\\n      [class.on]=\\\"input >= light\\\"\\n      [attr.cx]=\\\"center\\\"\\n      [attr.cy]=\\\"config.LIGHT_Y\\\"\\n      [attr.r]=\\\"config.LIGHT_RADIUS\\\">\\n    </circle>\\n    <text *ngIf=\\\"max > config.MAX_PURE_SCALE_VAL\\\"\\n      class=\\\"factor\\\"\\n      [attr.x]=\\\"center\\\"\\n      [attr.y]=\\\"config.S_FAC_Y\\\">\\n      x{{scaleFactor}} {{unit}}\\n    </text>\\n    <text *ngIf=\\\"showDigital\\\"\\n      class=\\\"digital\\\"\\n      [attr.x]=\\\"center\\\"\\n      [attr.y]=\\\"config.DIGITAL_Y\\\">\\n      {{input}}\\n    </text>\\n    <text class=\\\"unit\\\" [attr.x]=\\\"center\\\" [attr.y]=\\\"config.UNIT_Y\\\">{{unit}}</text>\\n  </svg>\\n  <svg #gauge [attr.viewBox]=\\\"viewBox\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path class=\\\"main-arc\\\" [attr.d]=\\\"arc\\\" [attr.stroke-width]=\\\"config.ARC_STROKE\\\" fill=\\\"none\\\" />\\n    <path *ngFor=\\\"let arc of sectorArcs\\\"\\n      [attr.d]=\\\"arc.path\\\"\\n      [attr.stroke]=\\\"arc.color\\\"\\n      [attr.stroke-width]=\\\"config.ARC_STROKE\\\"\\n      fill=\\\"none\\\" />\\n    <line *ngFor=\\\"let line of scaleLines\\\"\\n      [attr.stroke-width]=\\\"config.SL_WIDTH\\\"\\n      [attr.stroke]=\\\"line.color || (!lightTheme ? '#333' : '#fff')\\\"\\n      [attr.x1]=\\\"line.from.x\\\"\\n      [attr.y1]=\\\"line.from.y\\\"\\n      [attr.x2]=\\\"line.to.x\\\"\\n      [attr.y2]=\\\"line.to.y\\\" />\\n    <text *ngFor=\\\"let val of scaleValues\\\"\\n      class=\\\"text-val\\\"\\n      dominant-baseline=\\\"central\\\"\\n      [attr.x]=\\\"val.coor.x\\\"\\n      [attr.y]=\\\"val.coor.y\\\"\\n      [attr.transform]=\\\"'rotate(' + gaugeRotationAngle + ', ' + val.coor.x + ', ' + val.coor.y + ')'\\\">\\n      {{val.text}}\\n    </text>\\n    <rect #arrow\\n      class=\\\"arrow\\\"\\n      [attr.x]=\\\"center - config.ARROW_WIDTH / 2\\\"\\n      [attr.y]=\\\"config.ARROW_Y\\\"\\n      [attr.height]=\\\"center - config.ARROW_Y\\\"\\n      [attr.width]=\\\"config.ARROW_WIDTH\\\"\\n      [attr.rx]=\\\"config.ARROW_WIDTH / 2\\\"\\n      [attr.ry]=\\\"config.ARROW_WIDTH / 2\\\">\\n    </rect>\\n    <circle class=\\\"arrow-pin\\\" [attr.cx]=\\\"center\\\" [attr.cy]=\\\"center\\\" [attr.r]=\\\"config.ARROW_PIN_RAD\\\" />\\n  </svg>\\n</section>\\n\", styles: [\"@font-face{font-family:Orbitron;font-style:normal;font-weight:700;src:local(\\\"Orbitron Bold\\\"),local(\\\"Orbitron-Bold\\\"),url(https://fonts.gstatic.com/s/orbitron/v8/Y82YH_MJJWnsH2yUA5AuYY4P5ICox8Kq3LLUNMylGO4.woff2) format(\\\"woff2\\\");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2212,U+2215}.ng-gauge{position:relative;width:400px}.ng-gauge svg.info{position:absolute;top:0;left:0}.ng-gauge rect.arrow{transform-origin:50% 50%;fill:orange}.ng-gauge text{font-family:Orbitron,sans-serif;font-weight:700;text-anchor:middle;fill:#333}.ng-gauge.light text{fill:#fff}.ng-gauge text.text-val{font-size:12px}.ng-gauge circle.arrow-pin{fill:#333}.ng-gauge path.main-arc{stroke:#333}.ng-gauge.light path.main-arc{stroke:#fff}.ng-gauge text.factor{font-size:7px}.ng-gauge text.digital{font-size:16px}.ng-gauge text.unit{font-size:10px}.ng-gauge circle.red-light{fill:#ff4f4f;opacity:.1}.ng-gauge circle.red-light.on{opacity:1}\\n\"] }]\n    }], () => [{ type: i0.Renderer2 }], { gauge: [{\n            type: ViewChild,\n            args: ['gauge']\n        }], arrow: [{\n            type: ViewChild,\n            args: ['arrow']\n        }], size: [{\n            type: Input\n        }], start: [{\n            type: Input\n        }], end: [{\n            type: Input\n        }], sectors: [{\n            type: Input\n        }], unit: [{\n            type: Input\n        }], showDigital: [{\n            type: Input\n        }], light: [{\n            type: Input\n        }], lightTheme: [{\n            type: Input\n        }], factor: [{\n            type: Input\n        }], config: [{\n            type: Input\n        }], input: [{\n            type: Input\n        }], max: [{\n            type: Input\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(Ng2GaugeComponent, { className: \"Ng2GaugeComponent\" }); })();\n\nclass Ng2GaugeModule {\n    static { this.ɵfac = function Ng2GaugeModule_Factory(t) { return new (t || Ng2GaugeModule)(); }; }\n    static { this.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: Ng2GaugeModule }); }\n    static { this.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [BrowserModule] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Ng2GaugeModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [Ng2GaugeComponent],\n                imports: [\n                    BrowserModule\n                ],\n                exports: [Ng2GaugeComponent]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(Ng2GaugeModule, { declarations: [Ng2GaugeComponent], imports: [BrowserModule], exports: [Ng2GaugeComponent] }); })();\n\n/*\n * Public API Surface of ng2-gauge\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Ng2GaugeComponent, Ng2GaugeModule };\n//# sourceMappingURL=ng2-gauge.mjs.map\n","map":null,"preliminaryFileName":"ng2-gauge.mjs","sourcemapFileName":"ng2-gauge.mjs.map"},{"fileName":"ng2-gauge.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"ng2-gauge.mjs\",\"sources\":[\"../../../projects/ng2-gauge/src/lib/shared/ng2-gauge.interface.ts\",\"../../../projects/ng2-gauge/src/lib/shared/config.ts\",\"../../../projects/ng2-gauge/src/lib/shared/validators.ts\",\"../../../projects/ng2-gauge/src/lib/ng2-gauge.component.html\",\"../../../projects/ng2-gauge/src/lib/ng2-gauge.component.ts\",\"../../../projects/ng2-gauge/src/lib/ng2-gauge.module.ts\",\"../../../projects/ng2-gauge/src/public_api.ts\",\"../../../projects/ng2-gauge/src/ng2-gauge.ts\"],\"sourcesContent\":[\"import { GaugeConfig } from './config';\\n\\nexport interface Cartesian {\\n  x: number;\\n  y: number;\\n}\\n\\nexport interface Line {\\n  from: Cartesian;\\n  to: Cartesian;\\n  color: string;\\n}\\n\\nexport interface Value {\\n  coor: Cartesian;\\n  text: string;\\n}\\n\\nexport interface Sector {\\n  from: number;\\n  to: number;\\n  color: string;\\n}\\n\\nexport interface RenderSector {\\n  path: string;\\n  color: string;\\n}\\n\\nexport interface GaugeProps {\\n  start: number;\\n  end: number;\\n  max: number;\\n  sectors: Sector[];\\n  unit: string;\\n  showDigital: boolean;\\n  light: number;\\n  lightTheme: boolean;\\n  factor: number;\\n  config: GaugeConfig;\\n}\\n\\nexport enum Separator {\\n  NA,\\n  Big,\\n  Small,\\n}\\n\",\"export interface GaugeConfig {\\n  WIDTH: number;              // Width of the SVG (Use size input, if you want to change gauge size)\\n  ARC_STROKE: number;         // Stroke/width of the arc\\n  ARROW_Y: number;            // Distance from the arc to the tip of the arrow (Y position)\\n  ARROW_WIDTH: number;        // Arrow width/stroke\\n  ARROW_PIN_RAD: number;      // Radius of the arrow pin\\n  SL_NORM: number;            // Length of a scale line\\n  SL_MID_SEP: number;         // Length of a middle separator (a.k.a. small)\\n  SL_SEP: number;             // Length of a separator (a.k.a. big)\\n  SL_WIDTH: number;           // Scale line width/stroke\\n  TXT_MARGIN: number;         // Y margin for a scale value\\n  LIGHT_Y: number;            // Light Y position\\n  LIGHT_RADIUS: number;       // Radius of the light\\n  S_FAC_Y: number;            // Scale factor text Y position\\n  DIGITAL_Y: number;          // Digital gauge Y position\\n  UNIT_Y: number;             // Unit label Y position\\n  MAX_PURE_SCALE_VAL: number; // Max pure scale value (After that the scale shows only the multiplier)\\n  INIT_LINE_FREQ: number;     // Initial scale line frequency\\n  DEF_START: number;          // Default start angle (Use the input property in order to change)\\n  DEF_END: number;            // Default end angle (Use the input property in order to change)\\n}\\n\\nexport const Config: GaugeConfig = {\\n  WIDTH: 200,\\n  ARC_STROKE: 5,\\n  ARROW_Y: 22.5,\\n  ARROW_WIDTH: 4,\\n  ARROW_PIN_RAD: 8,\\n  SL_NORM: 3,\\n  SL_MID_SEP: 7,\\n  SL_SEP: 10,\\n  SL_WIDTH: 2,\\n  TXT_MARGIN: 10,\\n  LIGHT_Y: 55,\\n  LIGHT_RADIUS: 10,\\n  S_FAC_Y: 80,\\n  DIGITAL_Y: 145,\\n  UNIT_Y: 155,\\n  MAX_PURE_SCALE_VAL: 1000,\\n  INIT_LINE_FREQ: 2,\\n  DEF_START: 225,\\n  DEF_END: 135\\n};\\n\",\"import { GaugeProps, Sector } from './ng2-gauge.interface';\\n\\nconst showError = (text: string) => {\\n  console.error(`GaugeComponent: ${text}`);\\n};\\n\\nexport const validate = (props: GaugeProps) => {\\n  if (!props.max) {\\n    showError('The maximal value is not set.');\\n  }\\n\\n  if (!(0 <= props.start && props.start <= 359) || !(0 <= props.end && props.end <= 359)) {\\n    showError('The end and start must be between 0 and 359 degrees.');\\n  }\\n\\n  if (props.light && props.light > props.max) {\\n    showError('The red light trigger value cannot be greater than the max value of the gauge.');\\n  }\\n\\n  if (props.factor && props.factor >= props.max) {\\n    showError('The factor cannot be greater than or equal to the max value.');\\n  }\\n\\n  if (props.sectors) {\\n    props.sectors.forEach((s: Sector) => {\\n      if (s.from > props.max || s.to > props.max) {\\n        showError('The sector bounds cannot be greater than the max value.');\\n      }\\n\\n      if (s.from >= s.to) {\\n        showError('The lower bound of the sector cannot be greater than or equal to the upper one.');\\n      }\\n\\n      if (!s.color) {\\n        showError(`Sector[${s.from}, ${s.to}] color is empty.`);\\n      }\\n    });\\n  }\\n};\\n\",\"<section class=\\\"ng-gauge\\\" [class.light]=\\\"lightTheme\\\" [style.width]=\\\"size + 'px'\\\">\\n  <svg class=\\\"info\\\" [attr.viewBox]=\\\"viewBox\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <circle *ngIf=\\\"light\\\"  class=\\\"red-light\\\"\\n      [class.on]=\\\"input >= light\\\"\\n      [attr.cx]=\\\"center\\\"\\n      [attr.cy]=\\\"config.LIGHT_Y\\\"\\n      [attr.r]=\\\"config.LIGHT_RADIUS\\\">\\n    </circle>\\n    <text *ngIf=\\\"max > config.MAX_PURE_SCALE_VAL\\\"\\n      class=\\\"factor\\\"\\n      [attr.x]=\\\"center\\\"\\n      [attr.y]=\\\"config.S_FAC_Y\\\">\\n      x{{scaleFactor}} {{unit}}\\n    </text>\\n    <text *ngIf=\\\"showDigital\\\"\\n      class=\\\"digital\\\"\\n      [attr.x]=\\\"center\\\"\\n      [attr.y]=\\\"config.DIGITAL_Y\\\">\\n      {{input}}\\n    </text>\\n    <text class=\\\"unit\\\" [attr.x]=\\\"center\\\" [attr.y]=\\\"config.UNIT_Y\\\">{{unit}}</text>\\n  </svg>\\n  <svg #gauge [attr.viewBox]=\\\"viewBox\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path class=\\\"main-arc\\\" [attr.d]=\\\"arc\\\" [attr.stroke-width]=\\\"config.ARC_STROKE\\\" fill=\\\"none\\\" />\\n    <path *ngFor=\\\"let arc of sectorArcs\\\"\\n      [attr.d]=\\\"arc.path\\\"\\n      [attr.stroke]=\\\"arc.color\\\"\\n      [attr.stroke-width]=\\\"config.ARC_STROKE\\\"\\n      fill=\\\"none\\\" />\\n    <line *ngFor=\\\"let line of scaleLines\\\"\\n      [attr.stroke-width]=\\\"config.SL_WIDTH\\\"\\n      [attr.stroke]=\\\"line.color || (!lightTheme ? '#333' : '#fff')\\\"\\n      [attr.x1]=\\\"line.from.x\\\"\\n      [attr.y1]=\\\"line.from.y\\\"\\n      [attr.x2]=\\\"line.to.x\\\"\\n      [attr.y2]=\\\"line.to.y\\\" />\\n    <text *ngFor=\\\"let val of scaleValues\\\"\\n      class=\\\"text-val\\\"\\n      dominant-baseline=\\\"central\\\"\\n      [attr.x]=\\\"val.coor.x\\\"\\n      [attr.y]=\\\"val.coor.y\\\"\\n      [attr.transform]=\\\"'rotate(' + gaugeRotationAngle + ', ' + val.coor.x + ', ' + val.coor.y + ')'\\\">\\n      {{val.text}}\\n    </text>\\n    <rect #arrow\\n      class=\\\"arrow\\\"\\n      [attr.x]=\\\"center - config.ARROW_WIDTH / 2\\\"\\n      [attr.y]=\\\"config.ARROW_Y\\\"\\n      [attr.height]=\\\"center - config.ARROW_Y\\\"\\n      [attr.width]=\\\"config.ARROW_WIDTH\\\"\\n      [attr.rx]=\\\"config.ARROW_WIDTH / 2\\\"\\n      [attr.ry]=\\\"config.ARROW_WIDTH / 2\\\">\\n    </rect>\\n    <circle class=\\\"arrow-pin\\\" [attr.cx]=\\\"center\\\" [attr.cy]=\\\"center\\\" [attr.r]=\\\"config.ARROW_PIN_RAD\\\" />\\n  </svg>\\n</section>\\n\",\"import {\\n  Component,\\n  Input,\\n  ViewChild,\\n  OnInit,\\n  AfterViewInit,\\n  Renderer2,\\n  ElementRef,\\n  ViewEncapsulation,\\n} from '@angular/core';\\n\\nimport {\\n  Sector,\\n  Line,\\n  Cartesian,\\n  RenderSector,\\n  Value,\\n  Separator,\\n  GaugeProps,\\n} from './shared/ng2-gauge.interface';\\nimport { Config, GaugeConfig } from './shared/config';\\nimport { validate } from './shared/validators';\\n\\n@Component({\\n  selector: 'nga-ng2-gauge',\\n  templateUrl: './ng2-gauge.component.html',\\n  styleUrls: ['./ng2-gauge.component.css'],\\n  encapsulation: ViewEncapsulation.None,\\n})\\nexport class Ng2GaugeComponent implements OnInit, AfterViewInit, GaugeProps {\\n  @ViewChild('gauge') gauge!: ElementRef;\\n  @ViewChild('arrow') arrow!: ElementRef;\\n\\n  @Input() size!: number;\\n  @Input() start!: number;\\n  @Input() end!: number;\\n  @Input() sectors!: Sector[];\\n  @Input() unit!: string;\\n  @Input() showDigital!: boolean;\\n  @Input() light!: number;\\n  @Input() lightTheme!: boolean;\\n  @Input() factor!: number;\\n  @Input() config!: GaugeConfig;\\n\\n  viewBox!: string;\\n  scaleLines!: Line[];\\n  scaleValues!: Value[];\\n  sectorArcs!: RenderSector[];\\n\\n  radius!: number;\\n  center!: number;\\n  scaleFactor!: number;\\n\\n  private _end!: number;\\n  private _input!: number;\\n  private _max!: number;\\n  private _mappedSectors!: Sector[];\\n\\n  constructor(private _renderer: Renderer2) {}\\n\\n  @Input()\\n  set input(val: number) {\\n    this._input = val;\\n    this._updateArrowPos(val);\\n  }\\n\\n  get input(): number {\\n    return this._input;\\n  }\\n\\n  @Input()\\n  set max(val: number) {\\n    if (this._max) {\\n      this._max = val;\\n      this._initialize();\\n    }\\n    this._max = val;\\n  }\\n\\n  get max(): number {\\n    return this._max;\\n  }\\n\\n  get arc(): string {\\n    return this._arc(0, this._end);\\n  }\\n\\n  get gaugeRotationAngle(): number {\\n    return this._end - this.end;\\n  }\\n\\n  ngOnInit(): void {\\n    this.config = Object.assign(Config, this.config);\\n\\n    if (!this.start) {\\n      this.start = this.config.DEF_START;\\n    }\\n    if (!this.end) {\\n      this.end = this.config.DEF_END;\\n    }\\n\\n    validate(this);\\n\\n    const width = this.config.WIDTH + this.config.ARC_STROKE;\\n\\n    this.viewBox = `0 0 ${width} ${width}`;\\n    this.radius = this.config.WIDTH / 2;\\n    this.center = width / 2;\\n    this._end = this.end;\\n\\n    if (this.start > this.end) {\\n      this._end += 360 - this.start;\\n    } else {\\n      this._end -= this.start;\\n    }\\n\\n    this._initialize();\\n  }\\n\\n  ngAfterViewInit(): void {\\n    this._rotateGauge();\\n  }\\n\\n  /**\\n   * Initialize gauge.\\n   */\\n  private _initialize() {\\n    this.scaleLines = [];\\n    this.scaleValues = [];\\n\\n    this._calculateSectors();\\n    this._updateArrowPos(this._input);\\n    this.scaleFactor = this.factor || this._determineScaleFactor();\\n    this._createScale();\\n  }\\n\\n  /**\\n   * Calculate arc.\\n   */\\n  private _arc(start: number, end: number): string {\\n    const largeArc = end - start <= 180 ? 0 : 1;\\n    const startCoor = this._getAngleCoor(start);\\n    const endCoor = this._getAngleCoor(end);\\n\\n    return `M ${endCoor.x} ${endCoor.y} A ${this.radius} ${this.radius} 0 ${largeArc} 0 ${startCoor.x} ${startCoor.y}`;\\n  }\\n\\n  /**\\n   * Get angle coordinates (Cartesian coordinates).\\n   */\\n  private _getAngleCoor(degrees: number): Cartesian {\\n    const rads = ((degrees - 90) * Math.PI) / 180;\\n    return {\\n      x: this.radius * Math.cos(rads) + this.center,\\n      y: this.radius * Math.sin(rads) + this.center,\\n    };\\n  }\\n\\n  /**\\n   * Calculate/translate the user-defined sectors to arcs.\\n   */\\n  private _calculateSectors(): void {\\n    if (!this.sectors) {\\n      return;\\n    }\\n\\n    this._mappedSectors = JSON.parse(JSON.stringify(this.sectors));\\n    this._mappedSectors.forEach((s: Sector) => {\\n      const ratio = this._end / this.max;\\n      s.from *= ratio;\\n      s.to *= ratio;\\n    });\\n\\n    this.sectorArcs = this._mappedSectors.map((s: Sector) => {\\n      return {\\n        path: this._arc(s.from, s.to),\\n        color: s.color,\\n      };\\n    });\\n  }\\n\\n  /**\\n   * Update the position of the arrow based on the input.\\n   */\\n  private _updateArrowPos(input: number): void {\\n    const pos = (this._end / this.max) * input;\\n    this._renderer.setStyle(\\n      this.arrow.nativeElement,\\n      'transform',\\n      `rotate(${pos}deg)`,\\n    );\\n  }\\n\\n  /**\\n   * Rotate the gauge based on the start property. The CSS rotation, saves additional calculations with SVG.\\n   */\\n  private _rotateGauge(): void {\\n    const angle = 360 - this.start;\\n    this._renderer.setStyle(\\n      this.gauge.nativeElement,\\n      'transform',\\n      `rotate(-${angle}deg)`,\\n    );\\n  }\\n\\n  /**\\n   * Determine the scale factor (10^n number; i.e. if max = 9000 then scale_factor = 1000)\\n   */\\n  private _determineScaleFactor(factor = 10): number {\\n    // Keep smaller factor until 3X\\n    if (this.max / factor > 30) {\\n      return this._determineScaleFactor(factor * 10);\\n    }\\n    return factor;\\n  }\\n\\n  /**\\n   * Determine the line frequency which represents after what angle we should put a line.\\n   */\\n  private _determineLineFrequency(): number {\\n    const separators = this.max / this.scaleFactor;\\n    const separateAtAngle = this._end / separators;\\n    let lineFrequency: number;\\n\\n    // If separateAtAngle is not an integer, use its value as the line frequency.\\n    if (separateAtAngle % 1 !== 0) {\\n      lineFrequency = separateAtAngle;\\n    } else {\\n      lineFrequency = this.config.INIT_LINE_FREQ * 2;\\n      for (lineFrequency; lineFrequency <= separateAtAngle; lineFrequency++) {\\n        if (separateAtAngle % lineFrequency === 0) {\\n          break;\\n        }\\n      }\\n    }\\n\\n    return lineFrequency;\\n  }\\n\\n  /**\\n   * Checks whether the line (based on index) is big or small separator.\\n   */\\n  private _isSeparatorReached(idx: number, lineFrequency: number): Separator {\\n    const separators = this.max / this.scaleFactor;\\n    const totalSeparators = this._end / lineFrequency;\\n    const separateAtIdx = totalSeparators / separators;\\n\\n    if (idx % separateAtIdx === 0) {\\n      return Separator.Big;\\n    } else if (idx % (separateAtIdx / 2) === 0) {\\n      return Separator.Small;\\n    }\\n    return Separator.NA;\\n  }\\n\\n  /**\\n   * Creates the scale.\\n   */\\n  private _createScale(): void {\\n    const accumWith = this._determineLineFrequency() / 2;\\n    const isAboveSuitableFactor = this.max / this.scaleFactor > 10;\\n    let placedVals = 0;\\n\\n    for (\\n      let alpha = 0, i = 0;\\n      alpha >= -1 * this._end;\\n      alpha -= accumWith, i++\\n    ) {\\n      let lineHeight = this.config.SL_NORM;\\n      const sepReached = this._isSeparatorReached(i, accumWith);\\n\\n      // Set the line height based on its type\\n      switch (sepReached) {\\n        case Separator.Big:\\n          placedVals++;\\n          lineHeight = this.config.SL_SEP;\\n          break;\\n        case Separator.Small:\\n          lineHeight = this.config.SL_MID_SEP;\\n          break;\\n      }\\n\\n      // Draw the line\\n      const higherEnd = this.center - this.config.ARC_STROKE - 2;\\n      const lowerEnd = higherEnd - lineHeight;\\n\\n      const alphaRad = (Math.PI / 180) * (alpha + 180);\\n      const sin = Math.sin(alphaRad);\\n      const cos = Math.cos(alphaRad);\\n      const color = this._getScaleLineColor(alpha);\\n\\n      this._addScaleLine(sin, cos, higherEnd, lowerEnd, color);\\n\\n      // Put a scale value\\n      if (sepReached === Separator.Big) {\\n        const isValuePosEven = placedVals % 2 === 0;\\n        const isLast = alpha <= -1 * this._end;\\n\\n        if (!(isAboveSuitableFactor && isValuePosEven && !isLast)) {\\n          this._addScaleValue(sin, cos, lowerEnd, alpha);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Get the scale line color from the user-provided sectors definitions.\\n   */\\n  private _getScaleLineColor(alpha: number): string {\\n    alpha *= -1;\\n    let color = '';\\n\\n    if (this._mappedSectors) {\\n      this._mappedSectors.forEach((s: Sector) => {\\n        if (s.from <= alpha && alpha <= s.to) {\\n          color = s.color;\\n        }\\n      });\\n    }\\n\\n    return color;\\n  }\\n\\n  /**\\n   * Add a scale line to the list that will be later rendered.\\n   */\\n  private _addScaleLine(\\n    sin: number,\\n    cos: number,\\n    higherEnd: number,\\n    lowerEnd: number,\\n    color: string,\\n  ): void {\\n    this.scaleLines.push({\\n      from: {\\n        x: sin * higherEnd + this.center,\\n        y: cos * higherEnd + this.center,\\n      },\\n      to: {\\n        x: sin * lowerEnd + this.center,\\n        y: cos * lowerEnd + this.center,\\n      },\\n      color,\\n    });\\n  }\\n\\n  /**\\n   * Add a scale value.\\n   */\\n  private _addScaleValue(\\n    sin: number,\\n    cos: number,\\n    lowerEnd: number,\\n    alpha: number,\\n  ): void {\\n    let val = Math.round(alpha * (this.max / this._end)) * -1;\\n    let posMargin = this.config.TXT_MARGIN * 2;\\n\\n    // Use the multiplier instead of the real value, if above MAX_PURE_SCALE_VAL (i.e. 1000)\\n    if (this.max > this.config.MAX_PURE_SCALE_VAL) {\\n      val /= this.scaleFactor;\\n      val = Math.round(val * 100) / 100;\\n      posMargin /= 2;\\n    }\\n\\n    this.scaleValues.push({\\n      text: val.toString(),\\n      coor: {\\n        x: sin * (lowerEnd - posMargin) + this.center,\\n        y: cos * (lowerEnd - posMargin) + this.center,\\n      },\\n    });\\n  }\\n}\\n\",\"import { NgModule } from '@angular/core';\\nimport { BrowserModule } from '@angular/platform-browser';\\nimport { Ng2GaugeComponent } from './ng2-gauge.component';\\n\\n@NgModule({\\n  declarations: [Ng2GaugeComponent],\\n  imports: [\\n    BrowserModule\\n  ],\\n  exports: [Ng2GaugeComponent]\\n})\\nexport class Ng2GaugeModule { }\\n\",\"/*\\n * Public API Surface of ng2-gauge\\n */\\n\\nexport * from './lib/ng2-gauge.component';\\nexport * from './lib/ng2-gauge.module';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public_api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}